var editorOpen = false;
var editor = {};

document.getElementById('new-article-button').style.display = "block";
document.getElementById('save-button').style.display = "block";
document.getElementById('release-button').style.display = "block";

document.addEventListener('click', (event) => {

  // Check if we are clicking outside the editor
  let outsideEditor = true;
  event.composedPath().forEach((e) => { if (e && e.dataset && e.dataset.hasmd === 'true') outsideEditor = false; });

  // Close the editor if open and we are clicking outside it
  if (editorOpen && outsideEditor) {
    document.querySelectorAll('[editable]').forEach(element => {
      if (element.dataset.hasmd === 'true') {
        console.log('closing editor');

        // Remove editor
        element.removeChild(element.firstElementChild);

        // Remove preview class
        editor.preview.previewContent.classList.remove('toastui-editor-contents')

        // Append new child
        element.style = '';
        element.appendChild(editor.preview.previewContent);
        element.dataset.hasmd = 'false';
        editorOpen = false;
      }
    });
  }

  // Open an editor if we click an editable element
  event.composedPath().forEach(async (element) => {
    try {
      if (element.hasAttribute('editable') && element.dataset.hasmd !== 'true' && !editorOpen) {

        let markdown;

        if (element.getAttribute('editable') !== '') {
          if (element.dataset.md && element.dataset.md.length > 0) {
            markdown = element.dataset.md;
          } else {
            const url = `/markdowns/${element.getAttribute('editable').replace('__','/')}.md`;
            try {
              // Request the raw markdown (unusable until we have components in the markdown)
              const response = await fetch(url);
              if (response.status === 200) {
                markdown = await response.text();
                markdown = markdown.split('\n---')[1];
              }
            } catch (error) {
              console.error(error);
            }
          }
        }

        editor = new toastui.Editor({
          el: element,
          height: Math.max(element.offsetHeight, 450) + 'px',
          initialEditType: 'markdown',
          previewStyle: 'tab',
          usageStatistics: false,
          initialValue: markdown,
          language: 'pt-PT',
          events: {
            change: function(event) {
              element.dataset.md = editor.getMarkdown();
            }
          }
        });

        element.dataset.hasmd = 'true';
        editorOpen = true;
      }
    } catch (error) {}
  });

});

// Change all contenteditable from false to true
setTimeout(() => {
  document.querySelectorAll('[contenteditable]').forEach(element => {
    element.setAttribute('contenteditable','true');
  });
}, 0);

async function save () {
  showSpinnerOverlay();

  const contenteditableElements = document.querySelectorAll('[contenteditable]');
  const editableElements = document.querySelectorAll('[editable]');
  const newStrips = document.querySelectorAll('[newstrip]');

  for (let idx = 0; idx < contenteditableElements.length; idx++) {
    const element = contenteditableElements[idx];
    const prop = element.getAttribute('prop');
    const mdid = element.getAttribute('mdid');
    const stripid = element.getAttribute('stripid');
    if (prop && mdid) {
      try {
        const patchResponse = await fetch(`/api/properties/${mdid}`, {
          method: 'PATCH',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(
            {
              prop: prop,
              text: element.innerText
            })
          }
        );
      } catch (error) {
        console.log(error);
      }
    }
  }

  for (let idx = 0; idx < editableElements.length; idx++) {
    const element = editableElements[idx];
    const mdid = element.getAttribute('mdid');
    const stripid = element.getAttribute('stripid');
    if (element.dataset.md && element.getAttribute('editable') !== null && mdid && stripid) {
      try {
        const patchResponse = await fetch(`/api/markdown/${mdid}`, {
          method: 'PATCH',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(
            {
              stripid: stripid,
              markdown: element.dataset.md
            })
          }
        );
      } catch (error) {
        console.log(error);
      }
    }
  }

  for (let idx = 0; idx < newStrips.length; idx++) {
    const element = newStrips[idx];
    const mdid = document.querySelector('[mdid]').getAttribute('mdid');
    const mdelement = element.querySelector('[editable]');
    if (mdelement.dataset.md && mdid) {
      try {
        const putResponse = await fetch(`/api/markdown/${mdid}`, {
          method: 'PUT',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(
            {
              img: '/social.jpg',
              type: element.getAttribute('newstrip'),
              markdown: mdelement.dataset.md
            })
          }
        );
      } catch (error) {
        console.log(error);
      }
    }
  }

  await releaseBackoffice();

  location.reload();
}

function addStrip (stripType='img-right') {
  const slotDiv = document.getElementById('slotdiv');

  let template;
  switch (stripType) {
    case 'img-left':
      template = imgLeftStrip();
      break;
    case 'img-right':
      template = imgRightStrip();
      break;
    case 'no-img':
      template = noImgStrip();
      break;
    default:
      break;
  }
  if (template) {
    slotDiv.innerHTML += template;
  }
}

async function releaseBackoffice () {
  try {
    showSpinnerOverlay();
    await fetch('/api/release/backoffice', {method: 'GET'});
    console.log('release bo');
    hideSpinnerOverlay();
  } catch (error) {
    console.log(error);
  }
}

async function releasePublic () {
  try {
    showSpinnerOverlay();
    await fetch('/api/release/public', {method: 'GET'});
    console.log('release public');
    hideSpinnerOverlay();
  } catch (error) {
    console.log(error);
  }
}

async function creatArticle () {
  hideFormOverlay();

  let data = {};
  data.id = 'posts__' + document.getElementById("form-id").value;
  data.title = document.getElementById("form-tittle").value;
  data.description = document.getElementById("form-description").value;
  data.author = document.getElementById("form-author").value;

  const image = document.getElementById("form-image").files[0];

  if (image) {
    data.image = `/uploads/${image.name}`;
    let formData = new FormData();
    formData.append("image", image);

    try {
      const uploadResponse = await fetch("/api/upload/", { method: 'POST', body: formData });
    } catch (error) {
      console.log(error);
    }
  }

  try {
    showSpinnerOverlay();
    const postResponse = await fetch("/api/markdown/", { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data) });
    await releaseBackoffice();

    location.reload();
  } catch (error) {
    console.log(error);
  }
  return false;
}

function showSpinnerOverlay () {
  document.getElementById('spinner-overlay').style.display = "flex";
}

function hideSpinnerOverlay () {
  document.getElementById('spinner-overlay').style.display = "none";
}

function showFormOverlay () {
  document.getElementById('form-overlay').style.display = "flex";
}

function hideFormOverlay () {
  document.getElementById('form-overlay').style.display = "none";
}

function imgRightStrip () {

  return `<div newstrip="img-right" class="strip img-right">
  <div editable>

    <h3>Titulo temporario</h3>
    <p>Descrição temporaria</p>
  </div>
  <img src="/social.jpg"></img>
</div>
`;
}
function imgLeftStrip () {

  return `<div newstrip="img-left" class="strip img-left">
  <img src="/social.jpg"></img>
  <div editable>

    <h3>Titulo temporario</h3>
    <p>Descrição temporaria</p>
  </div>
</div>
`;
}
function noImgStrip () {

  return `<div newstrip="no-img" class="strip no-img">
  <div editable>

    <h3>Titulo temporario</h3>
    <p>Descrição temporaria</p>
  </div>
</div>
`;
}